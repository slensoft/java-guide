<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>多线程（JUC并发包） - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="small-font"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="多线程（JUC并发包）" class="main-title"></div></div></header><article><details class="wolai-block"><summary><div class="marker"></div><span>多线程基础</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>思路</span></summary><div class="wolai-block wolai-text"><p><span>先了解基本的一些概念，然后再把<span class="jill"></span>java.lang<span class="jill"></span>包下的</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/lang/Thread.html"><span>Thread</span></a></span><span>类相关字段、方法尝试用一遍。</span></p></div></details><details class="wolai-block"><summary><div class="marker"></div><span>进程、线程概念</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><blockquote class="wolai-block"><span>进程是对运行时程序的封装，是</span><span><strong>系统进行资源调度和分配的的基本单位，实现了操作系统的并发</strong></span><span>；</span></blockquote><blockquote class="wolai-block"><span>线程是进程的子任务，</span><span><strong>是<span class="jill"></span>CPU<span class="jill"></span>调度和分派的基本单位</strong></span><span>，</span><span><strong>用于保证程序的实时性，实现进程内部的并发；</strong></span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span>进程：是操作系统进行资源调度与分配的基本单位。</span></li><li><div class="marker"></div><span>线程：一个进程里面有多个线程，是<span class="jill"></span>CPU<span class="jill"></span>调度与分配的基本单位。</span></li><li><div class="marker"></div><span>（打个比方：进程类似工厂，线程就是工厂里面的小车间。打比方：qq、微信、浏览器就是进程，可以在操作系统的任务管理器中看到，进程中有<span class="jill"></span>1<span class="jill"></span>个或以上的线程。）</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><p><span><a href="https://mp.weixin.qq.com/s/zuWRx1FGuBC-_HwuA7jK3w"><span>一个故事讲完进程、线程和协程&nbsp;(qq.com)</span></a></span></p></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span class="red">线程创建实现的</span><span>三种方式</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>继承<span class="jill"></span>Thread</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>Thread<span class="jill"></span>类概念</span></summary><blockquote class="wolai-block"><span>线程是程序中执行的线程。&nbsp;Java<span class="jill"></span>虚拟机允许应用程序同时执行多个执行线程。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/lang/Thread.html"><span>Thread</span></a></span><span>类在<span class="jill"></span>java.lang<span class="jill"></span>包下。（在文档中有创建线程并启动的方法）</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>思路</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>这里先了解基本的线程创建，至于常用方法、字段属性之类的后面会接触到</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>实现</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>实现步骤</span></summary><ol class="wolai-block"><li><div class="marker"></div><span>创建一个类，继承<span class="jill"></span>Thread&nbsp;类，并实重写<span class="jill"></span>run()方法。</span></li><li><div class="marker"></div><span>创建线程类，并调用<span class="jill"></span>start()方法运行</span></li></ol></details><details class="wolai-block"><summary><div class="marker"></div><span>实现代码</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public class MyThread extends Thread {
    public <span class="token keyword">static</span> void <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> {
        <span class="token operator">/</span><span class="token operator">/</span> 第一种方式，继承Tread类，重新<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法，调用<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法启动线程
        new <span class="token function">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用继承Thread类的方法创建线程。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }
}</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>优缺点</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>优点：可以直接获取到当前线程<span class="jill"></span>this<span class="jill"></span>对象，而不需要使用<span class="jill"></span>Thread.currentThread()获取当前线程。</span></li><li><div class="marker"></div><span>缺点：继承了<span class="jill"></span>Thead<span class="jill"></span>类就不能继承其他类了（Java<span class="jill"></span>只能单继承）</span></li><li><div class="marker"></div><span>注意：不建议使用继承<span class="jill"></span>Tread<span class="jill"></span>类的方法，避免<span class="jill"></span>OOP<span class="jill"></span>单继承的局限性。</span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>实现<span class="jill"></span>Runable<span class="jill"></span>接口</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>Runable<span class="jill"></span>接口</span><span>概念</span></summary><blockquote class="wolai-block"><span><code>Runnable</code></span><span>接口应由任何类实现，其实例将由线程执行。&nbsp;该类必须定义一个无参数的方法，称为</span><span><code>run</code></span><span>&nbsp;。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span>可以通过实现</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/lang/Runnable.html"><span>Runnable</span></a></span><span>&nbsp;接口创建一个线程，不过这个线程必须实现<span class="jill"></span>run()方法</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>实现代码</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>实现步骤</span></summary><ol class="wolai-block"><li><div class="marker"></div><span>创建一个匿名类，这个匿名类（Lambda<span class="jill"></span>表达式）实现了<span class="jill"></span>Runnable<span class="jill"></span>接口</span></li><li><div class="marker"></div><span>将匿名类当作传入<span class="jill"></span>Thread<span class="jill"></span>类，调用<span class="jill"></span>start()方法运行。</span></li></ol><details class="wolai-block"><summary><div class="marker"></div><span>备注</span></summary><div class="wolai-block wolai-text"><p><span>备注：这里的传入的参数是<span class="jill"></span>Lambda<span class="jill"></span>表达式（传入的参数是一个实现了<span class="jill"></span>Runnable<span class="jill"></span>接口的匿名类），如果看不懂<span class="jill"></span>Lambda<span class="jill"></span>表达式建议查看我这边博客：</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#a9F14SvTX73gTZobeHUvcL" class="wolai-bi-link"><span>【Java&nbsp;进阶】JDK&nbsp;8&nbsp;推导<span class="jill"></span>Lambda<span class="jill"></span>简化过程_长生的梦呓-CSDN<span class="jill"></span>博客</span></a></span></p></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>代码</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        <span class="token operator">/</span><span class="token operator">/</span> 将实现Runnable接口的匿名类（也就是lambda表达式）当作参数传入创建的Thread对象中，然后调用start方法启动。
        new <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>{
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用实现Runnable接口创建线程。（这里使用了Lambda表达式创建了匿名类）"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>优缺点</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>优点：采用的是实现<span class="jill"></span>Runable<span class="jill"></span>接口，解决了继承<span class="jill"></span>Thread<span class="jill"></span>类出现的问题。并且可以使用<span class="jill"></span>Lambda<span class="jill"></span>表达式，让代码看起来更加简洁。</span></li><li><div class="marker"></div><span>缺点：如果需要访问当前线程需要使用<span class="jill"></span>Thread.currentThread()方法。</span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>实现<span class="jill"></span>Callable<span class="jill"></span>接口</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>可以说这个创建线程的方式是：通过<span class="jill"></span>FutureTask<span class="jill"></span>类，然后实现<span class="jill"></span>RunnableFuture<span class="jill"></span>接口创建线程，因为这个接口他继承了<span class="jill"></span>Callable<span class="jill"></span>和<span class="jill"></span>Future<span class="jill"></span>接口。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>Callable<span class="jill"></span>接口</span></summary><blockquote class="wolai-block"><span>返回结果并可能引发异常的任务。&nbsp;实现者定义一个没有参数的单一方法，称为</span><span><code>call</code></span><span>&nbsp;。</span><span><code>Callable</code></span><span>接口类似于</span><span><code>Runnable</code></span><span>&nbsp;，因为它们都是为其实例可能由另一个线程执行的类设计的。&nbsp;然而，</span><span><code>Runnable</code></span><span>不返回结果，也不能抛出被检查的异常。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/Callable.html"><span>Callable</span></a></span><span>是<span class="jill"></span>JUC<span class="jill"></span>并发包（java.util.</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/package-frame.html"><span>concurrent</span></a></span><span>包）下的一个接口，可以通过实现</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/Callable.html"><span>Callable</span></a></span><span>接口的<span class="jill"></span>call()方法创建一个线程。</span></li><li><div class="marker"></div><span>关键是实现</span><span><code>Runnable</code></span><span>接口的线程不返回结果，但是实现</span><span><code>Callable</code></span><span>接口的线程是会返回结果的。</span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>思路</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>一点点的了解这种线程创建的方法，建议点进去源码从接口开始了解。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>实现</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>实现步骤</span></summary><ol class="wolai-block"><li><div class="marker"></div><span>创建一个实现了<span class="jill"></span>Callable&lt;V&gt;接口的匿名类（Lambda<span class="jill"></span>表达式）。</span></li><li><div class="marker"></div><span>将匿名类当作参数传入创建的<span class="jill"></span>FutureTask&lt;V&gt;对象中。</span></li><li><div class="marker"></div><span>将创建的<span class="jill"></span>FutureTask&lt;V&gt;对象当作参数传入<span class="jill"></span>Thread<span class="jill"></span>对象中，然后调用<span class="jill"></span>start()方法运行。</span></li></ol><details class="wolai-block"><summary><div class="marker"></div><span>备注</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>为什么<span class="jill"></span>FutureTask&lt;V&gt;类中可以传入匿名类（就是<span class="jill"></span>Lambda<span class="jill"></span>表达式）？</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>因为<span class="jill"></span>FutureTask&lt;V&gt;有一个构造器，里面需要传入的参数就是<span class="jill"></span>Callable&lt;V&gt;接口。并且<span class="jill"></span>Callable&lt;V&gt;接口只有一个方法，他拥有<span class="jill"></span>@FunctionalInterface<span class="jill"></span>注解，所以可以传入<span class="jill"></span>lambda<span class="jill"></span>表达式。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>源码如下</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>utureTask&lt;V&gt;拥有一个单个参数的构造器，这个参数就是<span class="jill"></span>Callable&lt;V&gt;</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>    public <span class="token function">FutureTask</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">)</span> {
        <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            throw new <span class="token function">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        this<span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token comment" spellcheck="true">;</span>
        this<span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token comment" spellcheck="true">;       // ensure visibility of callable</span>
    }</pre></div><ul class="wolai-block"><li><div class="marker"></div><span>Callable&lt;V&gt;有<span class="jill"></span>@FunctionalInterface<span class="jill"></span>注解</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token variable">@FunctionalInterface</span>
public interface Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> {
    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> throws Exception<span class="token comment" spellcheck="true">;</span>
}</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>为什么<span class="jill"></span>FutureTask&lt;V&gt;对象可以当作参数传入<span class="jill"></span>Thread<span class="jill"></span>中？</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>因为<span class="jill"></span>FutureTask&lt;V&gt;实现了<span class="jill"></span>RunnableFuture&lt;V&gt;接口，而这个<span class="jill"></span>RunnableFuture&lt;V&gt;接口是继承自<span class="jill"></span>Runnable<span class="jill"></span>接口。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>源码如下</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public class FutureTask<span class="token operator">&lt;</span>V<span class="token operator">></span> implements RunnableFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> {
}</pre></div><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public interface RunnableFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> extends Runnable<span class="token punctuation">,</span> Future<span class="token operator">&lt;</span>V<span class="token operator">></span> {
    void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
}
</pre></div></details></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>代码</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        <span class="token operator">/</span><span class="token operator">/</span> 将实现Callable<span class="token operator">&lt;</span>V<span class="token operator">></span>接口的匿名类（也就是lambda表达式）当作参数传入创建的FutureTask<span class="token operator">&lt;</span>V<span class="token operator">></span>对象中
        <span class="token operator">/</span><span class="token operator">/</span> 再将新建的FutureTask<span class="token operator">&lt;</span>V<span class="token operator">></span>对象，传入Thread类中，运行start方法启动
        new <span class="token function">Thread</span><span class="token punctuation">(</span>
                new FutureTask<span class="token operator">&lt;</span>Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> {
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用实现Callable&lt;V>接口创建线程。（这里使用了Lambda表达式创建了匿名类）"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                    return <span class="token boolean">true</span><span class="token comment" spellcheck="true">;</span>
                }<span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span>优缺点</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>优点：</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>Callable<span class="jill"></span>的任务执行后可返回值，而<span class="jill"></span>Runnable<span class="jill"></span>的任务是不能返回值的。</span></li><li><div class="marker"></div><span>call<span class="jill"></span>方法可以抛出异常，run<span class="jill"></span>方法不可以。</span></li><li><div class="marker"></div><span>运行<span class="jill"></span>Callable<span class="jill"></span>任务可以拿到一个<span class="jill"></span>Future<span class="jill"></span>对象，表示异步计算的结果。</span></li></ul></details><ul class="wolai-block"><li><div class="marker"></div><span>所以通过这个方法，最主要的就是线程执行完后获得返回值。</span></li></ul></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><p><span><a href="https://blog.csdn.net/weixin_44034328/article/details/104366290"><span>【Java&nbsp;进阶】JDK&nbsp;8&nbsp;推导<span class="jill"></span>Lambda<span class="jill"></span>简化过程_长生的梦呓-CSDN<span class="jill"></span>博客</span></a></span></p></div><div class="wolai-block wolai-text"><p><span><a href="https://blog.csdn.net/qq_35275233/article/details/87893337"><span>java&nbsp;创建线程的三种方式、创建线程池的四种方式</span></a></span></p></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>线程状态</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>线程状态可以理解为线程的生命周期。</span></li><li><div class="marker"></div><span>点开<span class="jill"></span>Thread<span class="jill"></span>类中的内部枚举类</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/lang/Thread.State.html"><span>Thread.State</span></a></span><span>就可以看到所有的状态了。</span></li><li><div class="marker"></div><span>Java<span class="jill"></span>线程状态有：新建、运行、无限等待、限期等待、阻塞、结束</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>Java<span class="jill"></span>线程六</span><span>种</span><span>状态</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>NEW<span class="jill"></span>初始</span></summary><details class="wolai-block"><summary><div class="marker placeholder"></div><span>新创建线程时候，init<span class="jill"></span>初始化的时候就是初始状态，对应代码如下：</span></summary></details><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>Thread t <span class="token operator">=</span> new <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 196px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>RUNNABLE<span class="jill"></span>运行</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>调用<span class="jill"></span>start<span class="jill"></span>方法时候运行，则是运行状态了。在调用了这个方法之后才真正出现了一个线程，并且执行，状态也改变成了<span class="jill"></span>RUNNABLE</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 176px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>TERMINATED<span class="jill"></span>终止</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>线程执行完毕后就变成了终止状态</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_1.png" style="width: 176px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>BLOCKED<span class="jill"></span>阻塞</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>执行同步代码块<span class="jill"></span>sychronized<span class="jill"></span>进入阻塞状态<span class="jill"></span>BLOCKED，需要拿到锁才能运行（状态为<span class="jill"></span>RUNNABLE）</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_1.png" style="width: 276px"/></figure></div><ul class="wolai-block"><li><div class="marker"></div><span>比如，有一个锁对象&nbsp;A，线程&nbsp;1&nbsp;此时持有这把锁。线程&nbsp;2、3、4&nbsp;分别尝试抢这把锁失败。那么他们都会进入同步队列中，变成阻塞状态，如此往复。</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/image_2.png" style="width: 376px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>WAITING<span class="jill"></span>等待</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>概念图</span></summary><div class="wolai-block wolai-text"><p><span>&nbsp;进入等待状态：调用<span class="jill"></span>lock.wait()&nbsp;方法</span></p></div><div class="wolai-block wolai-center"><figure><img src="media/640.gif" style="width: 499px"/></figure></div><div class="wolai-block wolai-text"><p><span>唤醒：必须由另一个线程，调用同一个对象的&nbsp;notify()/notifyAll()&nbsp;方法。</span></p></div><div class="wolai-block wolai-center"><figure><img src="media/640.gif" style="width: 499px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>进入等待状态<span class="jill"></span>wait()后唤醒</span><span>notify()</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/image_3.png" style="width: 316px"/></figure></div><div class="wolai-block wolai-text"><p><span>扩展<span class="jill"></span>join<span class="jill"></span>方法：看<span class="jill"></span>join()方法源码，他的本质仍然是执行了&nbsp;wait()&nbsp;方法。</span></p></div><div class="wolai-block wolai-center"><figure><img src="media/image_3.png" style="width: 316px"/></figure></div><div class="wolai-block wolai-text"><p><span>扩展<span class="jill"></span>LockSupport.park()、LockSupport.unpark()方法</span></p></div><div class="wolai-block wolai-center"><figure><img src="media/image_4.png" style="width: 316px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span>常用方法</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>进入等待唤醒（来自<span class="jill"></span>Object<span class="jill"></span>类）</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>wait()：进入等待状态</span></li><li><div class="marker"></div><span>notify()：唤醒</span></li><li><div class="marker"></div><span>notifyAll()：唤醒所有</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>合并线程（可以参考</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#iDpJgLTKd4vpx9M21oUmZ9" class="wolai-bi-link"><span>状态图</span></a></span><span>和</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#8xXYECNWjW6TPMmeTcxMxh" class="wolai-bi-link"><span>图解线程状态，看完浑身通透&nbsp;(qq.com)</span></a></span><span>）</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>t.join()：等待线程死亡（等待<span class="jill"></span>t<span class="jill"></span>线程执行完后再执行其他线程，类似排队时候的<span class="jill"></span>vip<span class="jill"></span>插队）</span><div class="wolai-block wolai-text"><p><span>（优先执行<span class="jill"></span>t<span class="jill"></span>线程，直到<span class="jill"></span>t<span class="jill"></span>线程执行完了才执行主线程。执行<span class="jill"></span>t<span class="jill"></span>线程时候，此时的主线程为<span class="jill"></span>WAITING<span class="jill"></span>状态，直到<span class="jill"></span>t<span class="jill"></span>线程执行完了，主线程才会变成<span class="jill"></span>RUNNABLE&nbsp;状态）</span></p></div><div class="wolai-block wolai-text"><p><span>看<span class="jill"></span>join()方法源码，</span><span>他的本质仍然是执行了&nbsp;wait()&nbsp;方法。</span></p></div></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>扩展类（LockSupport）</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>从线程状态流转来看，与&nbsp;wait&nbsp;和&nbsp;notify&nbsp;相同。参考下面两个方法</span></li><li><div class="marker"></div><span>LockSupport.park()：该线程状态会从&nbsp;RUNNABLE&nbsp;变成&nbsp;WAITING</span></li><li><div class="marker"></div><span>LockSupport.unpark(Thread&nbsp;刚刚的线程)：调用这个，刚刚的线程会从&nbsp;WAITING&nbsp;回到&nbsp;RUNNABLE</span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>TIMED_WAITING<span class="jill"></span>定时等待</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>这个非常简单，就是上面的等待状态<span class="jill"></span>WAITING<span class="jill"></span>增加一个定时参数就是该状态了。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>这些方法的唯一区别就是，从&nbsp;TIMED_WAITING&nbsp;返回&nbsp;RUNNABLE，不但可以通过之前的方式，还可以通过到了超时时间，返回&nbsp;RUNNABLE&nbsp;状态。</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/image_5.png" style="width: 356px"/></figure></div><div class="wolai-block wolai-text"><p><span>Thread.sleep(long)：仅仅让线程挂起，只能通过等待超时时间到了再被唤醒</span></p></div><div class="wolai-block wolai-center"><figure><img src="media/image_5.png" style="width: 356px"/></figure></div><div class="wolai-block wolai-text"><p><span>最终的全局流程图：</span></p></div><div class="wolai-block wolai-center"><figure><img src="media/image_6.png" style="width: 356px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>扩展知识（Java<span class="jill"></span>线程六种状态、经典的线程五种状态区别）</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>java<span class="jill"></span>中的六种状态就是上面的六种</span></li><li><div class="marker"></div><span>经典的线程五种状态：创建、就绪、执行、阻塞、终止</span></li><li><div class="marker"></div><span>不同实现者，可能有合并和拆分。详情查看</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#8xXYECNWjW6TPMmeTcxMxh" class="wolai-bi-link"><span>图解线程状态，看完浑身通透</span></a></span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><p><span><a href="https://mp.weixin.qq.com/s/aG_uBLQevyZEFTOLK-kH9g"><span>图解线程状态，看完浑身通透</span></a></span></p></div><div class="wolai-block wolai-text"><p><span><a href="https://blog.csdn.net/pange1991/article/details/53860651"><span>Java<span class="jill"></span>线程的<span class="jill"></span>6<span class="jill"></span>种状态及切换(透彻讲解)_潘建南的博客</span></a></span></p></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>线程<span class="jill"></span>Thread<span class="jill"></span>常用方法</span></summary><div class="wolai-block wolai-text"><p><span>常用方法如下，相关使用可以查看<span class="jill"></span>API<span class="jill"></span>文档</span></p></div><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        Thread t <span class="token operator">=</span> new <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 查询线程信息
        long id <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        String name <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        int priority <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span> stackTrace <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        State state <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        ThreadGroup threadGroup <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        boolean alive <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        boolean daemon <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        boolean interrupted <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 修改线程
        t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"thread-name"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">setContextClassLoader</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>

        <span class="token operator">/</span><span class="token operator">/</span> 线程状态改变
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 线程的静态方法（还有一些静态字段、静态内部类，这里不过多罗列）
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        int i1 <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        Thread thread1 <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        boolean interrupted1 <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="red">线程同步</span></summary><details class="wolai-block"><summary><div class="marker placeholder"></div><span>同步方法</span></summary></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span>同步块</span></summary></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><p><span><a href="https://www.jianshu.com/p/9c6ea53500a2"><span>Synchronized<span class="jill"></span>同步方法和同步代码块&nbsp;-&nbsp;简书&nbsp;(jianshu.com)</span></a></span></p></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>线程</span><span>通信</span></summary><div class="wolai-block wolai-text"><p><span></span><div class="wolai-block wolai-text"><p><br/></p></div></p></div></details><details class="wolai-block"><summary><div class="marker"></div><span>线程池</span></summary><div class="wolai-block wolai-text"><p><span><a href="https://mp.weixin.qq.com/s/70u3d3c6VavgteGttIBoWA"><span>图解&nbsp;|&nbsp;你管这破玩意叫线程池？&nbsp;(qq.com)</span></a></span></p></div><div class="wolai-block wolai-text"><p><span><a href="https://mp.weixin.qq.com/s/rxaNWAgpt7umtftDk3eKUA"><span>从上厕所想到的线程池设计原理&nbsp;(qq.com)</span></a></span></p></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><p><span><a href="https://mp.weixin.qq.com/s/PrUa0tFyu3UZllP2FRDyVA"><span>【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&nbsp;(qq.com)</span></a></span></p></div><div class="wolai-block wolai-text"><p><span><a href="https://mp.weixin.qq.com/s/FaHKGRI69TqDj0AJtNiVoA"><span>进程和线程基础知识全家桶，30&nbsp;张图一套带走&nbsp;(qq.com)</span></a></span></p></div><div class="wolai-block wolai-text"><p><span><a href="https://www.bilibili.com/video/BV1V4411p7EF"><span>【狂神说<span class="jill"></span>Java】多线程详解_哔哩哔哩_bilibili</span></a></span></p></div></details></article><footer></footer></body></html>