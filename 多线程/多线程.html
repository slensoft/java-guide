<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>多线程 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="small-font"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="多线程" class="main-title"></div></div></header><article><details class="wolai-block"><summary><div class="marker"></div><span>多线程基础</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>思路</span></summary><ol class="wolai-block"><li><div class="marker"></div><span>先了解基本的一些概念，例如进程、线程。</span></li><li><div class="marker"></div><span>然后了解线程创建的三种方式和三种方式的优缺点</span></li><li><div class="marker"></div><span>再去详细了解线程的六种状态，与此同时学习<span class="jill"></span>Thread<span class="jill"></span>类中的常用方法，在学线程的等待机制时，顺便把线程通知中的等待/通知机制学习一下。</span></li><li><div class="marker"></div><span>线程的同步，synchronized<span class="jill"></span>和<span class="jill"></span>volatile<span class="jill"></span>关键字。</span></li><li><div class="marker"></div><span>线程通讯机制</span></li><li><div class="marker"></div><span>线程池学习</span></li></ol></details><details class="wolai-block"><summary><div class="marker"></div><span>1.进程、线程概念</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><blockquote class="wolai-block"><span>进程是对运行时程序的封装，是</span><span><strong>系统进行资源调度和分配的的基本单位，实现了操作系统的并发</strong></span><span>；</span></blockquote><blockquote class="wolai-block"><span>线程是进程的子任务，</span><span><strong>是<span class="jill"></span>CPU<span class="jill"></span>调度和分派的基本单位</strong></span><span>，</span><span><strong>用于保证程序的实时性，实现进程内部的并发；</strong></span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span>进程：是操作系统进行资源调度与分配的基本单位。</span></li><li><div class="marker"></div><span>线程：一个进程里面有多个线程，是<span class="jill"></span>CPU<span class="jill"></span>调度与分配的基本单位。</span></li><li><div class="marker"></div><span>（打个比方：进程类似工厂，线程就是工厂里面的小车间。打比方：qq、微信、浏览器就是进程，可以在操作系统的任务管理器中看到，进程中有<span class="jill"></span>1<span class="jill"></span>个或以上的线程。）</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://mp.weixin.qq.com/s/zuWRx1FGuBC-_HwuA7jK3w"><span>一个故事讲完进程、线程和协程&nbsp;(qq.com)</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://mp.weixin.qq.com/s/FaHKGRI69TqDj0AJtNiVoA"><span>进程和线程基础知识全家桶，30&nbsp;张图一套带走&nbsp;(qq.com)</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>2.线程创建（三种方式）</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>继承<span class="jill"></span>Thread</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>Thread<span class="jill"></span>类概念</span></summary><blockquote class="wolai-block"><span>线程是程序中执行的线程。&nbsp;Java<span class="jill"></span>虚拟机允许应用程序同时执行多个执行线程。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/lang/Thread.html"><span>Thread</span></a></span><span>类在<span class="jill"></span>java.lang<span class="jill"></span>包下。（在文档中有创建线程并启动的方法）</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>思路</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>这里先了解基本的线程创建，至于常用方法、字段属性之类的后面会接触到</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>实现</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>实现步骤</span></summary><ol class="wolai-block"><li><div class="marker"></div><span>创建一个类，继承<span class="jill"></span>Thread&nbsp;类，并实重写<span class="jill"></span>run()方法。</span></li><li><div class="marker"></div><span>创建线程类，并调用<span class="jill"></span>start()方法运行</span></li></ol></details><details class="wolai-block"><summary><div class="marker"></div><span>实现代码</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public class MyThread extends Thread {
    public <span class="token keyword">static</span> void <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> {
        <span class="token operator">/</span><span class="token operator">/</span> 第一种方式，继承Tread类，重新<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法，调用<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法启动线程
        new <span class="token function">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用继承Thread类的方法创建线程。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }
}</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>优缺点</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>优点：可以直接获取到当前线程<span class="jill"></span>this<span class="jill"></span>对象，而不需要使用<span class="jill"></span>Thread.currentThread()获取当前线程。</span></li><li><div class="marker"></div><span>缺点：继承了<span class="jill"></span>Thead<span class="jill"></span>类就不能继承其他类了（Java<span class="jill"></span>只能单继承）</span></li><li><div class="marker"></div><span>注意：不建议使用继承<span class="jill"></span>Tread<span class="jill"></span>类的方法，避免<span class="jill"></span>OOP<span class="jill"></span>单继承的局限性。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>扩展（线程<span class="jill"></span>Thread<span class="jill"></span>常用方法）</span></summary><div class="wolai-block wolai-text"><div><span>常用方法如下，相关使用可以查看<span class="jill"></span>API<span class="jill"></span>文档</span></div></div><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        Thread t <span class="token operator">=</span> new <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 查询线程信息
        long id <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        String name <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        int priority <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span> stackTrace <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        State state <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        ThreadGroup threadGroup <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        boolean alive <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        boolean daemon <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        boolean interrupted <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 修改线程
        t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"thread-name"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">setContextClassLoader</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>

        <span class="token operator">/</span><span class="token operator">/</span> 线程状态改变
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 线程的静态方法（还有一些静态字段、静态内部类，这里不过多罗列）
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        int i1 <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        Thread thread1 <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        boolean interrupted1 <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>实现<span class="jill"></span>Runable<span class="jill"></span>接口</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>Runable<span class="jill"></span>接口</span><span>概念</span></summary><blockquote class="wolai-block"><span><code>Runnable</code></span><span>接口应由任何类实现，其实例将由线程执行。&nbsp;该类必须定义一个无参数的方法，称为</span><span><code>run</code></span><span>&nbsp;。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span>可以通过实现</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/lang/Runnable.html"><span>Runnable</span></a></span><span>&nbsp;接口创建一个线程，不过这个线程必须实现<span class="jill"></span>run()方法</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>实现代码</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>实现步骤</span></summary><ol class="wolai-block"><li><div class="marker"></div><span>创建一个匿名类，这个匿名类（Lambda<span class="jill"></span>表达式）实现了<span class="jill"></span>Runnable<span class="jill"></span>接口</span></li><li><div class="marker"></div><span>将匿名类当作传入<span class="jill"></span>Thread<span class="jill"></span>类，调用<span class="jill"></span>start()方法运行。</span></li></ol><details class="wolai-block"><summary><div class="marker"></div><span>备注</span></summary><div class="wolai-block wolai-text"><div><span>备注：这里的传入的参数是<span class="jill"></span>Lambda<span class="jill"></span>表达式（传入的参数是一个实现了<span class="jill"></span>Runnable<span class="jill"></span>接口的匿名类），如果看不懂<span class="jill"></span>Lambda<span class="jill"></span>表达式建议查看我这边博客：</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#a9F14SvTX73gTZobeHUvcL" class="wolai-bi-link"><span><span><a href="https://blog.csdn.net/weixin_44034328/article/details/104366290"><span>【Java&nbsp;进阶】JDK&nbsp;8&nbsp;推导<span class="jill"></span>Lambda<span class="jill"></span>简化过程_长生的梦呓-CSDN<span class="jill"></span>博客</span></a></span></span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>代码</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        <span class="token operator">/</span><span class="token operator">/</span> 将实现Runnable接口的匿名类（也就是lambda表达式）当作参数传入创建的Thread对象中，然后调用start方法启动。
        new <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>{
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用实现Runnable接口创建线程。（这里使用了Lambda表达式创建了匿名类）"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>优缺点</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>优点：采用的是实现<span class="jill"></span>Runable<span class="jill"></span>接口，解决了继承<span class="jill"></span>Thread<span class="jill"></span>类出现的问题。并且可以使用<span class="jill"></span>Lambda<span class="jill"></span>表达式，让代码看起来更加简洁。</span></li><li><div class="marker"></div><span>缺点：如果需要访问当前线程需要使用<span class="jill"></span>Thread.currentThread()方法。</span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>实现<span class="jill"></span>Callable<span class="jill"></span>接口</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>可以说这个创建线程的方式是：通过<span class="jill"></span>FutureTask<span class="jill"></span>类，然后实现<span class="jill"></span>RunnableFuture<span class="jill"></span>接口创建线程，因为这个接口他继承了<span class="jill"></span>Callable<span class="jill"></span>和<span class="jill"></span>Future<span class="jill"></span>接口。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>Callable<span class="jill"></span>接口</span></summary><blockquote class="wolai-block"><span>返回结果并可能引发异常的任务。&nbsp;实现者定义一个没有参数的单一方法，称为</span><span><code>call</code></span><span>&nbsp;。</span><span><code>Callable</code></span><span>接口类似于</span><span><code>Runnable</code></span><span>&nbsp;，因为它们都是为其实例可能由另一个线程执行的类设计的。&nbsp;然而，</span><span><code>Runnable</code></span><span>不返回结果，也不能抛出被检查的异常。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/Callable.html"><span>Callable</span></a></span><span>是<span class="jill"></span>JUC<span class="jill"></span>并发包（java.util.</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/package-frame.html"><span>concurrent</span></a></span><span>包）下的一个接口，可以通过实现</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/Callable.html"><span>Callable</span></a></span><span>接口的<span class="jill"></span>call()方法创建一个线程。</span></li><li><div class="marker"></div><span>关键是实现</span><span><code>Runnable</code></span><span>接口的线程不返回结果，但是实现</span><span><code>Callable</code></span><span>接口的线程是会返回结果的。</span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>思路</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>一点点的了解这种线程创建的方法，建议点进去源码从接口开始了解。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>实现</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>实现步骤</span></summary><ol class="wolai-block"><li><div class="marker"></div><span>创建一个实现了<span class="jill"></span>Callable&lt;V&gt;接口的匿名类（Lambda<span class="jill"></span>表达式）。</span></li><li><div class="marker"></div><span>将匿名类当作参数传入创建的<span class="jill"></span>FutureTask&lt;V&gt;对象中。</span></li><li><div class="marker"></div><span>将创建的<span class="jill"></span>FutureTask&lt;V&gt;对象当作参数传入<span class="jill"></span>Thread<span class="jill"></span>对象中，然后调用<span class="jill"></span>start()方法运行。</span></li></ol><details class="wolai-block"><summary><div class="marker"></div><span>备注</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>为什么<span class="jill"></span>FutureTask&lt;V&gt;类中可以传入匿名类（就是<span class="jill"></span>Lambda<span class="jill"></span>表达式）？</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>因为<span class="jill"></span>FutureTask&lt;V&gt;有一个构造器，里面需要传入的参数就是<span class="jill"></span>Callable&lt;V&gt;接口。并且<span class="jill"></span>Callable&lt;V&gt;接口只有一个方法，他拥有<span class="jill"></span>@FunctionalInterface<span class="jill"></span>注解，所以可以传入<span class="jill"></span>lambda<span class="jill"></span>表达式。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>源码如下</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>utureTask&lt;V&gt;拥有一个单个参数的构造器，这个参数就是<span class="jill"></span>Callable&lt;V&gt;</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>    public <span class="token function">FutureTask</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">)</span> {
        <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            throw new <span class="token function">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        this<span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token comment" spellcheck="true">;</span>
        this<span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token comment" spellcheck="true">;       // ensure visibility of callable</span>
    }</pre></div><ul class="wolai-block"><li><div class="marker"></div><span>Callable&lt;V&gt;有<span class="jill"></span>@FunctionalInterface<span class="jill"></span>注解</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token variable">@FunctionalInterface</span>
public interface Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> {
    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> throws Exception<span class="token comment" spellcheck="true">;</span>
}</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>为什么<span class="jill"></span>FutureTask&lt;V&gt;对象可以当作参数传入<span class="jill"></span>Thread<span class="jill"></span>中？</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>因为<span class="jill"></span>FutureTask&lt;V&gt;实现了<span class="jill"></span>RunnableFuture&lt;V&gt;接口，而这个<span class="jill"></span>RunnableFuture&lt;V&gt;接口是继承自<span class="jill"></span>Runnable<span class="jill"></span>接口。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>源码如下</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public class FutureTask<span class="token operator">&lt;</span>V<span class="token operator">></span> implements RunnableFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> {
}</pre></div><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public interface RunnableFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> extends Runnable<span class="token punctuation">,</span> Future<span class="token operator">&lt;</span>V<span class="token operator">></span> {
    void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
}
</pre></div></details></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>代码</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        <span class="token operator">/</span><span class="token operator">/</span> 将实现Callable<span class="token operator">&lt;</span>V<span class="token operator">></span>接口的匿名类（也就是lambda表达式）当作参数传入创建的FutureTask<span class="token operator">&lt;</span>V<span class="token operator">></span>对象中
        <span class="token operator">/</span><span class="token operator">/</span> 再将新建的FutureTask<span class="token operator">&lt;</span>V<span class="token operator">></span>对象，传入Thread类中，运行start方法启动
        new <span class="token function">Thread</span><span class="token punctuation">(</span>
                new FutureTask<span class="token operator">&lt;</span>Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> {
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用实现Callable&lt;V>接口创建线程。（这里使用了Lambda表达式创建了匿名类）"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                    return <span class="token boolean">true</span><span class="token comment" spellcheck="true">;</span>
                }<span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span>优缺点</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>优点：</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>Callable<span class="jill"></span>的任务执行后可返回值，而<span class="jill"></span>Runnable<span class="jill"></span>的任务是不能返回值的。</span></li><li><div class="marker"></div><span>call<span class="jill"></span>方法可以抛出异常，run<span class="jill"></span>方法不可以。</span></li><li><div class="marker"></div><span>运行<span class="jill"></span>Callable<span class="jill"></span>任务可以拿到一个<span class="jill"></span>Future<span class="jill"></span>对象，表示异步计算的结果。</span></li></ul></details><ul class="wolai-block"><li><div class="marker"></div><span>所以通过这个方法，最主要的就是线程执行完后获得返回值。</span></li></ul></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://blog.csdn.net/weixin_44034328/article/details/104366290"><span>【Java&nbsp;进阶】JDK&nbsp;8&nbsp;推导<span class="jill"></span>Lambda<span class="jill"></span>简化过程_长生的梦呓-CSDN<span class="jill"></span>博客</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://blog.csdn.net/qq_35275233/article/details/87893337"><span>java&nbsp;创建线程的三种方式、创建线程池的四种方式</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>3.线程状态</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>线程状态可以理解为线程的生命周期。</span></li><li><div class="marker"></div><span>点开<span class="jill"></span>Thread<span class="jill"></span>类中的内部枚举类</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/lang/Thread.State.html"><span>Thread.State</span></a></span><span>就可以看到所有的状态了。</span></li><li><div class="marker"></div><span>Java<span class="jill"></span>线程状态有：新建、运行、无限等待、限期等待、阻塞、结束</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>Java<span class="jill"></span>线程六</span><span>种</span><span>状态</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>NEW<span class="jill"></span>初始</span></summary><details class="wolai-block"><summary><div class="marker placeholder"></div><span>新创建线程时候，init<span class="jill"></span>初始化的时候就是初始状态，对应代码如下：</span></summary></details><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>Thread t <span class="token operator">=</span> new <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image.png" style="width: 196px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>RUNNABLE<span class="jill"></span>运行</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>调用<span class="jill"></span>start<span class="jill"></span>方法时候运行，则是运行状态了。在调用了这个方法之后才真正出现了一个线程，并且执行，状态也改变成了<span class="jill"></span>RUNNABLE</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_1.png" style="width: 176px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>TERMINATED<span class="jill"></span>终止</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>线程执行完毕后就变成了终止状态</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_2.png" style="width: 176px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>BLOCKED<span class="jill"></span>阻塞</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>执行同步代码块<span class="jill"></span>sychronized<span class="jill"></span>进入阻塞状态<span class="jill"></span>BLOCKED，需要拿到锁才能运行（状态为<span class="jill"></span>RUNNABLE）</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_3.png" style="width: 276px"/></figure></div><ul class="wolai-block"><li><div class="marker"></div><span>比如，有一个锁对象&nbsp;A，线程&nbsp;1&nbsp;此时持有这把锁。线程&nbsp;2、3、4&nbsp;分别尝试抢这把锁失败。那么他们都会进入同步队列中，变成阻塞状态，如此往复。</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/image_4.png" style="width: 376px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>WAITING<span class="jill"></span>等待</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>概念图</span></summary><div class="wolai-block wolai-text"><div><span>&nbsp;进入等待状态：调用<span class="jill"></span>lock.wait()&nbsp;方法</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/640.gif" style="width: 499px"/></figure></div><div class="wolai-block wolai-text"><div><span>唤醒：必须由另一个线程，调用同一个对象的&nbsp;notify()/notifyAll()&nbsp;方法。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/640_1.gif" style="width: 499px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>进入等待状态<span class="jill"></span>wait()后唤醒</span><span>notify()</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/image_5.png" style="width: 316px"/></figure></div><div class="wolai-block wolai-text"><div><span>扩展<span class="jill"></span>join<span class="jill"></span>方法：看<span class="jill"></span>join()方法源码，他的本质仍然是执行了&nbsp;wait()&nbsp;方法。</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_6.png" style="width: 316px"/></figure></div><div class="wolai-block wolai-text"><div><span>扩展<span class="jill"></span>LockSupport.park()、LockSupport.unpark()方法</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_7.png" style="width: 316px"/></figure></div></details><details class="wolai-block"><summary><div class="marker"></div><span>等待/通知机制</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>A<span class="jill"></span>线程调用对象<span class="jill"></span>O<span class="jill"></span>的<span class="jill"></span>wait()会进入等待状态，只有别的线程例如<span class="jill"></span>B<span class="jill"></span>线程调用<span class="jill"></span>O<span class="jill"></span>的<span class="jill"></span>notify()/notifyAll()方法才会被唤醒，进入<span class="jill"></span>RUNNABLE<span class="jill"></span>状态，继续运行。</span></li><li><div class="marker"></div><span>一个形象的例子就是厨师和服务员之间就存在等待/通知机制，服务员通知做菜后等待厨师做完然后上菜。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>常用方法</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>wait()：进入等待状态</span></li><li><div class="marker"></div><span>notify()：</span><span>通知</span><span>唤醒</span></li><li><div class="marker"></div><span>notifyAll()：唤醒所有</span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>线程的<span class="jill"></span>Waiting<span class="jill"></span>状态扩展</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>合并线程<span class="jill"></span>join</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>t.join()：等待线程死亡（等待<span class="jill"></span>t<span class="jill"></span>线程执行完后再执行其他线程，类似排队时候的<span class="jill"></span>vip<span class="jill"></span>插队（优先执行<span class="jill"></span>t<span class="jill"></span>线程，直到<span class="jill"></span>t<span class="jill"></span>线程执行完了才执行主线程。执行<span class="jill"></span>t<span class="jill"></span>线程时候，此时的主线程为<span class="jill"></span>WAITING<span class="jill"></span>状态，直到<span class="jill"></span>t<span class="jill"></span>线程执行完了，主线程才会变成<span class="jill"></span>RUNNABLE&nbsp;状态）</span></li><li><div class="marker"></div><span>看<span class="jill"></span>join()方法源码，他的本质仍然是执行了&nbsp;wait()&nbsp;方法。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>LockSupport<span class="jill"></span>类</span></summary><blockquote class="wolai-block"><span>用于创建锁和其他同步类的基本线程阻塞原语。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span>从线程状态流转来看，</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/locks/LockSupport.html"><span>LockSupport</span></a></span><span>中两个方法<span class="jill"></span>park()/unpark()与&nbsp;wait()/notify()相同。</span></li><li><div class="marker"></div><span>LockSupport.park()：该线程状态会从&nbsp;RUNNABLE&nbsp;变成&nbsp;WAITING</span></li><li><div class="marker"></div><span>LockSupport.unpark(Thread&nbsp;刚刚的线程)：调用这个，刚刚的线程会从&nbsp;WAITING&nbsp;回到&nbsp;RUNNABLE</span></li></ul></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>TIMED_WAITING<span class="jill"></span>定时等待</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>这个非常简单，就是上面的等待状态<span class="jill"></span>WAITING<span class="jill"></span>增加一个定时参数就是该状态了。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>流程图</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>这些方法的唯一区别就是，从&nbsp;TIMED_WAITING&nbsp;返回&nbsp;RUNNABLE，不但可以通过之前的方式，还可以通过到了超时时间，返回&nbsp;RUNNABLE&nbsp;状态。</span></li></ul><div class="wolai-block wolai-center"><figure><img src="media/image_8.png" style="width: 356px"/></figure></div><div class="wolai-block wolai-text"><div><span>Thread.sleep(long)：仅仅让线程挂起，只能通过等待超时时间到了再被唤醒</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_9.png" style="width: 356px"/></figure></div><div class="wolai-block wolai-text"><div><span>最终的全局流程图：</span></div></div><div class="wolai-block wolai-center"><figure><img src="media/image_10.png" style="width: 356px"/></figure></div></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>问题</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>Java<span class="jill"></span>线程六种状态、经典的线程五种状态区别？</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>java<span class="jill"></span>中的六种状态就是上面的六种。</span></li><li><div class="marker"></div><span>但是经典的线程五种状态：创建、就绪、执行、阻塞、终止。</span></li><li><div class="marker"></div><span>不同实现者，可能有合并和拆分。</span><span>注意不要混淆二者！</span><span>详情查看</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#8xXYECNWjW6TPMmeTcxMxh" class="wolai-bi-link"><span><span><a href="https://mp.weixin.qq.com/s/aG_uBLQevyZEFTOLK-kH9g"><span>图解线程状态，看完浑身通透</span></a></span></span></a></span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://mp.weixin.qq.com/s/aG_uBLQevyZEFTOLK-kH9g"><span>图解线程状态，看完浑身通透</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://blog.csdn.net/pange1991/article/details/53860651"><span>Java<span class="jill"></span>线程的<span class="jill"></span>6<span class="jill"></span>种状态及切换(透彻讲解)_潘建南的博客</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://mp.weixin.qq.com/s/PrUa0tFyu3UZllP2FRDyVA"><span>【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&nbsp;(qq.com)</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>4.线程通讯</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>线程通信主要可以分为三种方式，分别为</span><span><strong>共享内存</strong></span><span>、</span><span><strong>消息传递</strong></span><span>和</span><span><strong>管道流</strong></span><span>。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>共享内存</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>主要实现是通过<span class="jill"></span>volatile<span class="jill"></span>关键字来实现的。</span></li><li><div class="marker"></div><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#oSTQPrniZ1ZjBuXvynhtwi" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>volatile<span class="jill"></span>关键字</span></span></a></span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>消息传递</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>wait/notify<span class="jill"></span>等待通知方式</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>Java<span class="jill"></span>中最常见的实现方式是<span class="jill"></span>synchronized&nbsp;+&nbsp;wait()&nbsp;+&nbsp;notify()&nbsp;/&nbsp;notifyAll()</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#bYNcyyK83wRLXbe577RatJ" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>等待/通知机制</span></span></a></span></li><li><div class="marker"></div><span></span><br/></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>生产者消费者模式（经典范式）</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>解决同一个资源在多线程并发访问时的完整性。</span></li><li><div class="marker"></div><span>核心思路：在生产者消费者中间添加一个“内存缓冲区”（用于存储数据），然后生产者产生数据放入缓冲区，消费者从缓冲区获取数据。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>概念图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_11.png" style="width: 476px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>代码示例</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>有好几种实现方式，我这里只写了最简单的实现方式。详情看</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#piz2ttLfMY7s8FY7ZMczEs" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>参考</span></span></a></span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public class Demo {
    public <span class="token keyword">static</span> void <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>{
        Storage storage <span class="token operator">=</span> new <span class="token function">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> <span class="token number">3</span>个生产者为仓库产生产品
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"p1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"p2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"p3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> <span class="token number">5</span>个消费者消费仓库产生的产品
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Consumer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"m1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Consumer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"m2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Consumer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"m3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Consumer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"m4"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Consumer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"m5"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }
}
<span class="token operator">/</span><span class="token operator">/</span> 仓库（缓冲区）
class Storage{
    <span class="token operator">/</span><span class="token operator">/</span> 产品列表
    private LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> products <span class="token operator">=</span> new LinkedList<span class="token operator">&lt;></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    <span class="token operator">/</span><span class="token operator">/</span> 产品列表最大容量
    private <span class="token keyword">static</span> final int MAX_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token comment" spellcheck="true">;</span>
    <span class="token operator">/</span><span class="token operator">/</span> 生产操作
    public void <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> throws InterruptedException {
        synchronized <span class="token punctuation">(</span>products<span class="token punctuation">)</span> {
            <span class="token keyword">if</span> <span class="token punctuation">(</span>products<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> MAX_SIZE<span class="token punctuation">)</span> {
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"生产者：生产了一个产品。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                products<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"产品"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            } <span class="token keyword">else</span> {
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"生产者：仓库满了暂时不生产了！生产者进入等待状态，并通知所有消费者（所有等待中的线程）。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                products<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
            <span class="token operator">/</span><span class="token operator">/</span> 唤醒所有等待中的线程
            products<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }
    }
    <span class="token operator">/</span><span class="token operator">/</span> 消费操作
    public void <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> throws InterruptedException {
        synchronized <span class="token punctuation">(</span>products<span class="token punctuation">)</span> {
            <span class="token keyword">if</span> <span class="token punctuation">(</span>products<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> {
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\t"</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"消费者：消费了一个产品。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                products<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"产品"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            } <span class="token keyword">else</span> {
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\t"</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"消费者：仓库中没有产品了！消费者进入等待状态，并通知所有生产者（所有等待中的线程）。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                products<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
            <span class="token operator">/</span><span class="token operator">/</span> 唤醒所有等待中的线程
            products<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }
    }
}
<span class="token operator">/</span><span class="token operator">/</span> 生产者
class Producer implements Runnable{
    <span class="token operator">/</span><span class="token operator">/</span> 仓库
    private Storage storage<span class="token comment" spellcheck="true">;</span>
    public <span class="token function">Producer</span><span class="token punctuation">(</span>Storage storage<span class="token punctuation">)</span>{
        this<span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>{
        <span class="token function">for</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">;;){</span>
            try{
                <span class="token operator">/</span><span class="token operator">/</span> <span class="token number">1</span>秒生产一个
                storage<span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }catch <span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span>{
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
        }
    }
}
<span class="token operator">/</span><span class="token operator">/</span> 消费者
class Consumer implements Runnable{
    <span class="token operator">/</span><span class="token operator">/</span> 仓库
    private Storage storage<span class="token comment" spellcheck="true">;</span>
    public <span class="token function">Consumer</span><span class="token punctuation">(</span>Storage storage<span class="token punctuation">)</span>{
        this<span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>{
        <span class="token function">for</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">;;){</span>
            try{
                <span class="token operator">/</span><span class="token operator">/</span> <span class="token number">3</span>秒消费一个
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                storage<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }catch <span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span>{
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
        }
    }
}</pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://blog.csdn.net/ldx19980108/article/details/81707751"><span>Java<span class="jill"></span>多种方式解决生产者消费者问题（十分详细）</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>信号灯法</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>信号灯法一般是线程的交替执行。（思路类似生产者消费者法，但是没</span><span>有缓冲区</span><span>）</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>
<span class="token operator">/</span><span class="token operator">/</span> 信号灯（实现两个线程：行人、司机交替进行操作，红灯时）
class TrafficLight{
    <span class="token operator">/</span><span class="token operator">/</span> 信号灯是否红灯（<span class="token boolean">true</span>代表红灯，不允许开车，但是允许行人通过）
    private boolean isRedLight <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true">;</span>
    <span class="token operator">/</span><span class="token operator">/</span> 信号灯刷新时间
    private final int REFRESH_TIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token comment" spellcheck="true">;</span>
    <span class="token operator">/</span><span class="token operator">/</span> 小车司机开车通过（synchronized锁当前的信号灯对象）
    public synchronized void <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>{
        <span class="token keyword">if</span> <span class="token punctuation">(</span>!isRedLight<span class="token punctuation">)</span> {
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小车司机开车通过信号灯。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            try {
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>REFRESH_TIME<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            } catch <span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span> {
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
            isRedLight <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true">;</span>
        }
    }
    <span class="token operator">/</span><span class="token operator">/</span> 行人走路步行通过（synchronized锁当前的信号灯对象）
    public synchronized void <span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>{
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isRedLight<span class="token punctuation">)</span> {
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"行人走路步行通过信号灯。"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            try {
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>REFRESH_TIME<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            } catch <span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span> {
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
            isRedLight <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment" spellcheck="true">;</span>
        }
    }
}
<span class="token operator">/</span><span class="token operator">/</span> 行人
class Pedestrian implements Runnable {
    private TrafficLight trafficLight<span class="token comment" spellcheck="true">;</span>
    public <span class="token function">Pedestrian</span><span class="token punctuation">(</span>TrafficLight trafficLight<span class="token punctuation">)</span> {
        this<span class="token punctuation">.</span>trafficLight <span class="token operator">=</span> trafficLight<span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">;;) {</span>
            trafficLight<span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }
    }
}
<span class="token operator">/</span><span class="token operator">/</span> 司机
class Driver implements Runnable {
    private TrafficLight trafficLight<span class="token comment" spellcheck="true">;</span>
    public <span class="token function">Driver</span><span class="token punctuation">(</span>TrafficLight trafficLight<span class="token punctuation">)</span> {
        this<span class="token punctuation">.</span>trafficLight <span class="token operator">=</span> trafficLight<span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">;;) {</span>
            trafficLight<span class="token punctuation">.</span><span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }
    }
}
</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>join<span class="jill"></span>方式</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#fAcxAy4ypBy3BqTqvGKWKt" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>合并线程<span class="jill"></span>join</span></span></a></span><span>（强制先执行调用<span class="jill"></span>join()方法的线程）</span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>管道流</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://www.wolai.com/5c7ZnacrjXZHhqYKfWArow#wZWq35QGsmAX95moBZNsjc" class="wolai-bi-link"><span><span class="embed-jiu embed-bullet"></span><span>管道流使用场景：主要用于线程之间的数据传输，传输媒介是内存。</span></span></a></span></div></div><ul class="wolai-block"><li><div class="marker"></div><span>管道流（</span><span>管道</span><span>输入/输出流）是<span class="jill"></span>IO<span class="jill"></span>流下的相关类。</span></li><li><div class="marker"></div><span>管道字节流：PipedOutputStream、&nbsp;PipedInputStream。</span></li><li><div class="marker"></div><span>管道</span><span>字符流：PipedWriter、&nbsp;PipedReader</span></li><li><div class="marker"></div><span>管道输入/输出流思想就是生产者消费者模式的实现，详情可以看源码。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>思路图</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_12.png" style="width: 586px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>代码</span></summary><div class="wolai-block wolai-text"><div><span>通过管道流中的</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/io/PipedInputStream.html#connect-java.io.PipedOutputStream-"><span>connect</span></a></span><span>(</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/io/PipedOutputStream.html"><span>PipedOutputStream</span></a></span><span>&nbsp;src)方法，使得两个管道流产生连接。</span></div></div><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>
public class Demo {
    public <span class="token keyword">static</span> void <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> throws IOException {
        PipedReader <span class="token keyword">in</span> <span class="token operator">=</span> new <span class="token function">PipedReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        PipedWriter out <span class="token operator">=</span> new <span class="token function">PipedWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token keyword">in</span><span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Reader</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">Writer</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }
}

class Reader implements Runnable {
    PipedReader pr<span class="token comment" spellcheck="true">;</span>
    public <span class="token function">Reader</span><span class="token punctuation">(</span>PipedReader pr<span class="token punctuation">)</span> {
        this<span class="token punctuation">.</span>pr <span class="token operator">=</span> pr<span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        try {
            int rs <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> pr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> !<span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> {
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span> rs<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
        } catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> {
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }
    }
}

class Writer implements Runnable {
    PipedWriter pw<span class="token comment" spellcheck="true">;</span>
    public <span class="token function">Writer</span><span class="token punctuation">(</span>PipedWriter pw<span class="token punctuation">)</span> {
        this<span class="token punctuation">.</span>pw <span class="token operator">=</span> pw<span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        try {
            int rs <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token keyword">in</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> !<span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> {
                pw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
        } catch <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> {
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }
    }
}</pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://blog.csdn.net/fxkcsdn/article/details/86562043"><span>【Java<span class="jill"></span>并发编程】管道输入输出流<span class="jill"></span>PipedReader/PipedWriter</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://zhuanlan.zhihu.com/p/359027560"><span>Java<span class="jill"></span>多线程（十）线程间通信</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>5.并发编程（同步）</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>3<span class="jill"></span>大特征</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>原子性</span></summary><blockquote class="wolai-block"><span>定义：即一个或者多个操作作为一个整体，要么全部执行，要么都不执行，并且操作在执行过程中不会被线程调度机制打断；而且这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。（言而言之，原子性就是不可再分割的操作，要么全部执行，要么都不执行）</span></li><li><div class="marker"></div><span>简而言之，原子同步！</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>备注</span></summary><div class="wolai-block wolai-text"><div><span>注意！面试时经常会问比较<span class="jill"></span>synchronized<span class="jill"></span>和<span class="jill"></span>volatile，它们俩特性上最大的区别就在于原子性，volatile<span class="jill"></span>不具备原子性（只具备</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#x9Md3y27BBikQHZh8yDsRs" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>可见性</span></span></a></span><span>）。</span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>可见性</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。简单来说：A<span class="jill"></span>线程改了变量<span class="jill"></span>v<span class="jill"></span>的值，B<span class="jill"></span>线程可以知道这个值该修改了，这就是可见性。</span></li><li><div class="marker"></div><span>可见性解决：</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#oSTQPrniZ1ZjBuXvynhtwi" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>volatile<span class="jill"></span>关键字</span></span></a></span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>有序性</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>即程序执行的顺序按照代码的先后顺序执行。</span></li><li><div class="marker"></div><span>就是代码是一行一行执行下来的</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://zhuanlan.zhihu.com/p/158611376"><span>并发编程的<span class="jill"></span>3<span class="jill"></span>大特征，这些你都彻底明白了吗？</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>原子性（同步）</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>synchronized<span class="jill"></span>关键字</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>synchronized<span class="jill"></span>控制对对象的访问，每一个对象都一个锁，只有拿到锁才能进行相关操作，否则会阻塞。</span></li><li><div class="marker"></div><span>方法一旦执行，就占有了锁，直到方法执行完毕才会释放锁，后面阻塞的线程才可以获取到锁。</span></li><li><div class="marker"></div><span>修改（增加删除）的时候才需要同步，查询不需要</span></li><li><div class="marker"></div><span>synchronized<span class="jill"></span>可以修饰静态方法、成员函数，同时还可以直接定义代码块，但是归根结底它上锁的资源只有两类：</span><span><strong>一个是对象，一个是类</strong></span><span>。</span><details class="wolai-block"><summary><div class="marker"></div><span>举例</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>举例：修饰实例方法就是锁</span><span><strong>对象</strong></span><span>，因为他是实例化对象之后才调用的方法。</span></li><li><div class="marker"></div><span>举例：修饰静态方法则是锁</span><span><strong>类</strong></span><span>的，这个静态方法归类所有（通过类名调用静态方法）。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>备注</span></summary><div class="wolai-block wolai-text"><div><span>重点弄清楚这些锁是上给谁（类、对象），就应该很容易懂<span class="jill"></span>synchronized<span class="jill"></span>的使用啦，其他的只要记住：要进入同步方法/同步块时执行方法，就必须先获得相应的锁才行。</span></div></div><div class="wolai-block wolai-text"><div><span>注意：只有锁类的时候，只有直接通过类名调用静态方法才是锁类。如果是<span class="jill"></span>new<span class="jill"></span>一个对象，那么他锁的还是一个对象具体可以看</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#4KfqzGqE7PDugk6SVoXqUx" class="wolai-bi-link"><span><span><a href="https://cloud.tencent.com/developer/article/1465413"><span>深入理解<span class="jill"></span>synchronized<span class="jill"></span>底层原理，一篇文章就够了！</span></a></span></span></a></span><span>中是示例。</span></div></div></details></details></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>三种用法</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>修饰实例方法（</span><span>同步方法</span><span>）</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>synchronized void <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
  <span class="token operator">/</span><span class="token operator">/</span>业务代码
}</pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span>修饰静态方法（同步方法）</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>synchronized void staic <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
  <span class="token operator">/</span><span class="token operator">/</span>业务代码
}</pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span>修饰代码块（同步块）</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token function">synchronized</span><span class="token punctuation">(</span>this<span class="token punctuation">)</span> {
  <span class="token operator">/</span><span class="token operator">/</span>业务代码
}</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://www.cnblogs.com/three-fighter/p/14396208.html"><span>synchronized<span class="jill"></span>详解&nbsp;-&nbsp;三分恶</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://cloud.tencent.com/developer/article/1465413"><span>深入理解<span class="jill"></span>synchronized<span class="jill"></span>底层原理，一篇文章就够了！</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>Lock<span class="jill"></span>接口锁</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><blockquote class="wolai-block"><span><code>Lock</code></span><span>实现提供比使用</span><span><code>synchronized</code></span><span>方法和语句可以获得的更广泛的锁定操作。</span></blockquote><blockquote class="wolai-block"><span>在<span class="jill"></span>Lock<span class="jill"></span>接口出现之前，Java<span class="jill"></span>程序是靠<span class="jill"></span>synchronized<span class="jill"></span>关键字实现锁功能的。JDK1.5<span class="jill"></span>之后并发包中新增了<span class="jill"></span>Lock<span class="jill"></span>接口以及相关实现类来实现锁功能。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span>&nbsp;</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/locks/Lock.html"><span>Lock</span></a></span><span>接口下的相关实现类，例如<span class="jill"></span>ReentrantLock<span class="jill"></span>可以实现和<span class="jill"></span>synchronized<span class="jill"></span>关键字一样的功能。需要注意的是，使用<span class="jill"></span>Lock<span class="jill"></span>接口的实现类实现同步操作时，需要显式写出相关的上锁和锁释放代码。</span></li><li><div class="marker"></div><span>不过使用<span class="jill"></span>Lock<span class="jill"></span>的实现类只能锁代码块。</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>使用示例</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>官方建议的是使用<span class="jill"></span>try<span class="jill"></span>语句将他包裹，具体查看</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/locks/ReentrantLock.html"><span>ReentrantLock</span></a></span><span>中示例</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>  Lock lock<span class="token operator">=</span>new <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
  lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
  <span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">do</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/locks/Lock.html"><span>Lock</span></a></span><span>接口</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><blockquote class="wolai-block"><span>一个可重入互斥</span><span><code>Lock</code></span><span>具有与使用</span><span><code>synchronized</code></span><span>方法和语句访问的隐式监视锁相同的基本行为和语义，但具有扩展功能。</span></blockquote><ul class="wolai-block"><li><div class="marker"></div><span>通过<span class="jill"></span>Lock<span class="jill"></span>接口下的</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/locks/ReentrantLock.html"><span>ReentrantLock</span></a></span><span>实现类可以实现和<span class="jill"></span>synchronized<span class="jill"></span>关键字一样的功能。不过只能锁同步代码块，而不能锁同步方法。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>Lock<span class="jill"></span>接口常用方法</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>接口方法</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        Lock lock <span class="token operator">=</span> new <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 上锁
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 释放锁
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 获取Condition
        Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span>ReentrantLock<span class="jill"></span>常用方法</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>仅仅是一小部分方法，更多的请查看<span class="jill"></span>api</span></li></ul><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        ReentrantLock lock <span class="token operator">=</span> new <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 查询当前线程对此锁的暂停数量
        int holdCount <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 查询等待获取此锁的线程数量（预估数）
        int queueLength <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">getQueueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 查询是否有线程等待获取此锁
        boolean b <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 查询此锁是否由任何线程持有
        boolean locked <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 设置为此锁的公平设置为<span class="token boolean">true</span>
        boolean fair <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">isFair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>代码</span></summary><div class="wolai-block wolai-text"><div><span>使用<span class="jill"></span>Lock<span class="jill"></span>实现同步代码块，让数字<span class="jill"></span>n<span class="jill"></span>能同步减到<span class="jill"></span>10。</span></div></div><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public class MyThread extends Thread {
    public <span class="token keyword">static</span> void <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> {
        MyThread t <span class="token operator">=</span> new <span class="token function">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }

    Lock lock <span class="token operator">=</span> new <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    int n <span class="token operator">=</span> <span class="token number">10</span><span class="token comment" spellcheck="true">;</span>

    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">;;) {</span>
            <span class="token operator">/</span><span class="token operator">/</span> 上锁
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            try {
                <span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">do</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> {
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                } <span class="token keyword">else</span> {
                    break<span class="token comment" spellcheck="true">;</span>
                }
            } catch <span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span> {
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            } finally {
                <span class="token operator">/</span><span class="token operator">/</span> 释放锁
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
        }
    }
}</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/locks/Condition.html"><span>Condition</span></a></span><span>接口</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>借助锁中的<span class="jill"></span>lock.newCondition()方法，获取<span class="jill"></span>Condition。</span></li><li><div class="marker"></div><span>可以实现线程等待/通知机制（Object<span class="jill"></span>类中的<span class="jill"></span>wait()和<span class="jill"></span>notify/notifyAll()方法）</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>方法的类比</span></summary><div class="wolai-block wolai-text"><div><span>对接口中相关的方法理解类比如下：</span></div></div><ul class="wolai-block"><li><div class="marker"></div><span>wait()&nbsp;==&nbsp;&nbsp;相当于<span class="jill"></span>Object<span class="jill"></span>类的<span class="jill"></span>wait<span class="jill"></span>方法</span></li><li><div class="marker"></div><span>await(long&nbsp;time,&nbsp;TimeUnit&nbsp;unit)&nbsp;&nbsp;&nbsp;==&nbsp;相当于<span class="jill"></span>Object<span class="jill"></span>类的<span class="jill"></span>wait(long&nbsp;timeout)方法</span></li><li><div class="marker"></div><span>signal()&nbsp;==&nbsp;相当于<span class="jill"></span>Object<span class="jill"></span>类的<span class="jill"></span>notify<span class="jill"></span>方法</span></li><li><div class="marker"></div><span>signalAll()&nbsp;==</span><span>相当于<span class="jill"></span>Object<span class="jill"></span>类的<span class="jill"></span>notifyAll<span class="jill"></span>方法</span></li></ul></details></details><details class="wolai-block"><summary><div class="marker"></div><span>使用单个<span class="jill"></span>Condition<span class="jill"></span>实现等待/通知机制</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public class MyThread extends Thread {
    public <span class="token keyword">static</span> void <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> throws InterruptedException {
        MyService service <span class="token operator">=</span> new <span class="token function">MyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 开启新线程
        new <span class="token function">ThreadA</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 主线程睡眠<span class="token number">3</span>秒再调用业务通知（service<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>）
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        service<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }

    <span class="token keyword">static</span> public class MyService {
        private Lock lock <span class="token operator">=</span> new <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        public Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>

        public void <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            try {
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" await时间为"</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是condition.await()方法之后的语句，condition.signal()方法之后我才被执行"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            } catch <span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span> {
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            } finally {
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
        }

        public void <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> throws InterruptedException {
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            try {
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"signal时间为"</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是condition.signal()方法之后的语句"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            } finally {
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }
        }
    }

    <span class="token keyword">static</span> public class ThreadA extends Thread {
        private MyService service<span class="token comment" spellcheck="true">;</span>

        public <span class="token function">ThreadA</span><span class="token punctuation">(</span>MyService service<span class="token punctuation">)</span> {
            this<span class="token punctuation">.</span>service <span class="token operator">=</span> service<span class="token comment" spellcheck="true">;</span>
        }

        <span class="token variable">@Override</span>
        public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
            service<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }
    }
}</pre></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://cloud.tencent.com/developer/article/1151531"><span>Java<span class="jill"></span>多线程学习（六）Lock<span class="jill"></span>锁的使用</span></a></span></div></div></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>可见性</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>volatile<span class="jill"></span>关键字</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>volatile</span><span>解决了线程间的（可以是变量、对象）“</span><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#x9Md3y27BBikQHZh8yDsRs" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>可见性</span></span></a></span><span>”</span></li><li><div class="marker"></div><span>简单来说线程<span class="jill"></span>A<span class="jill"></span>中改变了变量<span class="jill"></span>v<span class="jill"></span>值，线程<span class="jill"></span>B<span class="jill"></span>中可以清楚的知道。</span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>简单示例</span></summary><div class="wolai-block wolai-text"><div><span>使用<span class="jill"></span>volatile<span class="jill"></span>关键字，解决程序中变量的可见性。</span></div></div><div class="wolai-block wolai-text"><div><span>代码解释：当在主线程中，修改了对象<span class="jill"></span>t<span class="jill"></span>的变量值<span class="jill"></span>isRunning&nbsp;，那么在子线程中可以立马可见感知到变量的修改。</span></div></div><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>public class Demo {
    public <span class="token keyword">static</span> void <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> throws InterruptedException {
        MyThread t <span class="token operator">=</span> new <span class="token function">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 一秒后设置为<span class="token boolean">false</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        t<span class="token punctuation">.</span><span class="token function">setRunning</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经赋值为false"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }
}
class MyThread implements Runnable{
    <span class="token operator">/</span><span class="token operator">/</span> 如果不加上<span class="token keyword">volatile</span>则会出现死循环
    private <span class="token keyword">volatile</span> boolean isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true">;</span>
    int m<span class="token comment" spellcheck="true">;</span>
    public boolean <span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        return isRunning<span class="token comment" spellcheck="true">;</span>
    }
    public void <span class="token function">setRunning</span><span class="token punctuation">(</span>boolean isRunning<span class="token punctuation">)</span> {
        this<span class="token punctuation">.</span>isRunning <span class="token operator">=</span> isRunning<span class="token comment" spellcheck="true">;</span>
    }
    <span class="token variable">@Override</span>
    public void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入run了"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>isRunning<span class="token punctuation">)</span> {
            <span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">do</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            m <span class="token operator">=</span> <span class="token number">1</span><span class="token comment" spellcheck="true">;</span>
        }
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程被停止了！"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
    }
}</pre></div><div class="wolai-block wolai-text"><div><span>注意：volatile<span class="jill"></span>只是解决了线程间的变量可见性，并没有解决同步问题，所以如果需要同步，那么还需要使用例如<span class="jill"></span>synchronized<span class="jill"></span>关键字</span></div></div><div class="wolai-block wolai-text"><div><span></span><br/></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://cloud.tencent.com/developer/inventory/6073/article/1148462"><span>Java<span class="jill"></span>多线程学习（三）volatile<span class="jill"></span>关键字</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://www.cnblogs.com/zhengbin/p/5654805.html"><span>Java<span class="jill"></span>中<span class="jill"></span>Volatile<span class="jill"></span>关键字详解&nbsp;-&nbsp;郑斌<span class="jill"></span>blog&nbsp;-&nbsp;博客园&nbsp;(cnblogs.com)</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://mp.weixin.qq.com/s/2tuUq1QOtfhARfXh5VQx8A"><span>volatile&nbsp;三部曲之可见性&nbsp;(qq.com)</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://www.bilibili.com/video/BV1d64y1X7gG"><span>面试被问傻了,Java<span class="jill"></span>中<span class="jill"></span>Volatile<span class="jill"></span>关键字详解，别再说不懂<span class="jill"></span>volatile<span class="jill"></span>关键字！</span></a></span></div></div></details></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>问题与扩展</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>死锁</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>并发编程时，可能会出现资源争夺的情况，从而产生死锁</span></li><li><div class="marker"></div><span>参考博客：</span><span><a href="https://www.cnblogs.com/xiaoxi/p/8311034.html"><span>Java<span class="jill"></span>多线程：死锁</span></a></span></li></ul></details><details class="wolai-block"><summary><div class="marker"></div><span>ThreadLocal</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><ul class="wolai-block"><li><div class="marker"></div><span>ThreadLocal<span class="jill"></span>并不是一个<span class="jill"></span>Thread，而是<span class="jill"></span>Thread<span class="jill"></span>的局部变量（</span><span>LocalVariable</span><span>），也许把它命名为<span class="jill"></span>ThreadLocalVariable<span class="jill"></span>更容易让人理解一些。</span></li><li><div class="marker"></div><span>ThreadLocal<span class="jill"></span>是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。</span></li><li><div class="marker"></div><span>简单来说，就是将在每一个线程中，都一个一个局部变量的副本，修改这个副本对其他线程没有影响</span></li></ul><details class="wolai-block"><summary><div class="marker"></div><span>解释</span></summary><div class="wolai-block wolai-center"><figure><img src="media/image_13.png" style="width: 615px"/></figure></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>代码</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> tl <span class="token operator">=</span> ThreadLocal<span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> 下面两个线程进行测试
        new <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> {
            <span class="token operator">/</span><span class="token operator">/</span>每个线程调度get函数获取本线程的副本。
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            <span class="token operator">/</span><span class="token operator">/</span> set函数set的值，只会设置本线程的值，不会对其他线程有任何影响。
            tl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        new <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> {
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            tl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://www.jianshu.com/p/6fc3bba12f38"><span>ThreadLocal<span class="jill"></span>作用、场景、原理</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://www.jianshu.com/p/1ff73d2d7520"><span>ThreadLocal<span class="jill"></span>的使用方法、作用、使用场景和原理</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="http://www.jasongj.com/java/threadlocal/"><span>这才是&nbsp;Thread&nbsp;Local&nbsp;的正确原理与适用场景</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://blog.csdn.net/qq_35190492/article/details/116431270"><span>ThreadLocal<span class="jill"></span>使用与原理</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#6uSBqGL3qYWLiDfKMaQBfz" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>线程的<span class="jill"></span>Waiting<span class="jill"></span>状态扩展</span></span></a></span></summary><details class="wolai-block"><summary><div class="marker placeholder"></div><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#fAcxAy4ypBy3BqTqvGKWKt" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>合并线程<span class="jill"></span>join</span></span></a></span></summary></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span><a href="https://www.wolai.com/wXgqkvuFuVjVhdC5hsbEBk#hnZgPfDuvmzDa1Dtd3Lg5E" class="wolai-bi-link"><span><span class="embed-jiu embed-toggle"></span><span>LockSupport<span class="jill"></span>类</span></span></a></span></summary></details></details><details class="wolai-block"><summary><div class="marker"></div><span>上下文切换</span></summary><blockquote class="wolai-block"><span>当前任务在执行完<span class="jill"></span>CPU<span class="jill"></span>时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。</span><span><strong>任务从保存到再加载的过程就是一次上下文切换</strong></span><span>。</span></blockquote><div class="wolai-block wolai-text"><div><span>简单来说就是线程切换</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://cloud.tencent.com/developer/inventory/6073/article/1151533"><span>Java<span class="jill"></span>多线程学习（七）并发编程中一些问题&nbsp;-&nbsp;阅读清单&nbsp;-&nbsp;云<span class="jill"></span>+<span class="jill"></span>社区&nbsp;-&nbsp;腾讯云&nbsp;(tencent.com)</span></a></span></div></div></details></details><details class="wolai-block"><summary><div class="marker"></div><span>线程池</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>思路</span></summary><ol class="wolai-block"><li><div class="marker"></div><span>先学会基础的线程池创建语使用</span></li><li><div class="marker"></div><span>深入工具类细节</span></li></ol></details><details class="wolai-block"><summary><div class="marker"></div><span>概念</span></summary><div class="wolai-block wolai-text"><div><span>相较于我们上面的三种创建线程的方式，JDK&nbsp;5<span class="jill"></span>开始提供了<span class="jill"></span>Executor<span class="jill"></span>线程池框架，可以通过它进行线程的创建，统一管理。</span></div></div><div class="wolai-block wolai-text"><div><span>优点：提升了系统的性能以及使用率（通过线程池重复利用已创建的线程，避免了频繁创建/销毁线程对象。通过线程池统一管理线程）</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span>简单使用</span></summary><details class="wolai-block"><summary><div class="marker"></div><span>工具类<span class="jill"></span>Executors</span></summary><blockquote class="wolai-block"><span>工厂和工具方法</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/Executor.html"><span><code>Executor</code></span></a></span><span>&nbsp;，&nbsp;</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/ExecutorService.html"><span><code>ExecutorService</code></span></a></span><span>&nbsp;，&nbsp;</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/ScheduledExecutorService.html"><span><code>ScheduledExecutorService</code></span></a></span><span>&nbsp;，&nbsp;</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/ThreadFactory.html"><span><code>ThreadFactory</code></span></a></span><span>和</span><span><a href="https://www.mklab.cn/onlineapi/jdk_8_cn/java/util/concurrent/Callable.html"><span><code>Callable</code></span></a></span><span>在此包中定义的类。</span></blockquote><div class="wolai-block wolai-text"><div><span>直接可以使用这个工具类线程池<span class="jill"></span>Executors<span class="jill"></span>创建线程，里面全是静态方法直接调用。</span></div></div><details class="wolai-block"><summary><div class="marker"></div><span>简单使用代码</span></summary><div class="wolai-block wolai-pre"><div data-lang="Java" class="marker"></div><pre>        <span class="token operator">/</span><span class="token operator">/</span> <span class="token number">1</span><span class="token punctuation">.</span>创建
        ExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        <span class="token operator">/</span><span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">.</span>执行
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true">; i &lt; 10; i++) {</span>
            executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> {
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
            }<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>
        }
        <span class="token operator">/</span><span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">.</span>关闭
        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span></pre></div></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span>常用方法</span></summary></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://www.jianshu.com/p/7ab4ae9443b9"><span>Java<span class="jill"></span>线程池的使用&nbsp;-&nbsp;简书&nbsp;(jianshu.com)</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://cloud.tencent.com/developer/inventory/6073/article/1157685"><span>Java<span class="jill"></span>多线程学习（八）线程池与<span class="jill"></span>Executor&nbsp;框架</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://mp.weixin.qq.com/s/70u3d3c6VavgteGttIBoWA"><span>图解&nbsp;|&nbsp;你管这破玩意叫线程池？&nbsp;(qq.com)</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://mp.weixin.qq.com/s/G2cAMBpkpt6WtxPkc9kBQQ"><span>叮咚&nbsp;|&nbsp;线程池为什么设计成这样？&nbsp;(qq.com)</span></a></span></div></div></details></details></details><details class="wolai-block"><summary><div class="marker"></div><span>参考</span></summary><div class="wolai-block wolai-text"><div><span><a href="https://cloud.tencent.com/developer/inventory/6073"><span>Java<span class="jill"></span>多线程学习的全部内容&nbsp;-&nbsp;阅读清单</span></a></span></div></div><div class="wolai-block wolai-text"><div><span><a href="https://www.bilibili.com/video/BV1B7411L7tE"><span>【狂神说<span class="jill"></span>Java】JUC<span class="jill"></span>并发编程最新版通俗易懂_哔哩哔哩_bilibili</span></a></span></div></div></details><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>